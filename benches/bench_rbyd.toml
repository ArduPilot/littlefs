

# set block_size to the full size of disk so we can test arbitrarily
# large rbyd trees, we don't really care about block sizes at this
# abstraction level
defines.BLOCK_SIZE = 'DISK_SIZE'

[cases.bench_rbyd_attr_commit]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, cfg) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .rev = 1,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    BENCH_START();
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = *LFSR_ATTR(
                    UATTR(i_ & 0xff), -1, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(UATTR(i_ & 0xff), -1, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }
    BENCH_STOP();

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, cfg->block_size, NULL) => 0;
'''

[cases.bench_rbyd_attr_fetch]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, cfg) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .rev = 1,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = *LFSR_ATTR(
                    UATTR(i_ & 0xff), -1, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(UATTR(i_ & 0xff), -1, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    BENCH_START();
    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, cfg->block_size, NULL) => 0;
    BENCH_STOP();
'''

[cases.bench_rbyd_attr_lookup]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, cfg) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .rev = 1,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = *LFSR_ATTR(
                    UATTR(i_ & 0xff), -1, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(UATTR(i_ & 0xff), -1, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, cfg->block_size, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_tag_t tag_;
    lfs_ssize_t id_;
    lfs_off_t off_;
    lfs_size_t size_;
    int err = lfsr_rbyd_lookup(&lfs, &rbyd,
            LFSR_TAG_UATTR(i_ & 0xff), -1,
            &tag_, &id_, &off_, &size_);
    // note that random order may have some collisions
    assert(!err || err == LFS_ERR_NOENT);
    BENCH_STOP();
'''

[cases.bench_rbyd_attr_append]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, cfg) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .rev = 1,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = *LFSR_ATTR(
                    UATTR(i_ & 0xff), -1, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(UATTR(i_ & 0xff), -1, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, cfg->block_size, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_rbyd_commit(&lfs, &rbyd,
            LFSR_ATTR(UATTR(i_ & 0xff), -1, "\xbb\xbb\xbb\xbb", 4, NULL)) => 0;
    BENCH_STOP();

    uint8_t buffer[4];
    lfsr_rbyd_get(&lfs, &rbyd, LFSR_TAG_UATTR(i_ & 0xff), -1, buffer, 4) => 4;
    assert(memcmp(buffer, "\xbb\xbb\xbb\xbb", 4) == 0);
'''

[cases.bench_rbyd_attr_remove]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, cfg) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .rev = 1,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = *LFSR_ATTR(
                    UATTR(i_ & 0xff), -1, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(UATTR(i_ & 0xff), -1, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, cfg->block_size, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_rbyd_commit(&lfs, &rbyd,
            LFSR_ATTR(RMUATTR(i_ & 0xff), -1, NULL, 0, NULL)) => 0;
    BENCH_STOP();

    uint8_t buffer[4];
    lfsr_rbyd_get(&lfs, &rbyd, LFSR_TAG_UATTR(i_ & 0xff), -1, buffer, 4)
            => LFS_ERR_NOENT;
'''

[cases.bench_rbyd_id_commit]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, cfg) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .rev = 1,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    BENCH_START();
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            attrs[i] = *LFSR_ATTR(
                    MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }
    BENCH_STOP();

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, cfg->block_size, NULL) => 0;
'''

[cases.bench_rbyd_id_fetch]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, cfg) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .rev = 1,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            attrs[i] = *LFSR_ATTR(
                    MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    BENCH_START();
    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, cfg->block_size, NULL) => 0;
    BENCH_STOP();
'''

[cases.bench_rbyd_id_lookup]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, cfg) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .rev = 1,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            attrs[i] = *LFSR_ATTR(
                    MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, cfg->block_size, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_tag_t tag_;
    lfs_ssize_t id_;
    lfs_off_t off_;
    lfs_size_t size_;
    lfsr_rbyd_lookup(&lfs, &rbyd, LFSR_TAG_MKREG, i_,
            &tag_, &id_, &off_, &size_) => 0;
    assert(tag_ == LFSR_TAG_MKREG);
    assert(id_ == i_);
    BENCH_STOP();
'''

[cases.bench_rbyd_id_create]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, cfg) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .rev = 1,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            attrs[i] = *LFSR_ATTR(
                    MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, cfg->block_size, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % (N+1);
    lfsr_rbyd_commit(&lfs, &rbyd,
            LFSR_ATTR(MKREG, i_, "\xbb\xbb\xbb\xbb", 4,
            NULL)) => 0;
    BENCH_STOP();

    uint8_t buffer[4];
    lfsr_rbyd_get(&lfs, &rbyd, LFSR_TAG_MKREG, i_, buffer, 4) => 4;
    assert(memcmp(buffer, "\xbb\xbb\xbb\xbb", 4) == 0);
'''

[cases.bench_rbyd_id_delete]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, cfg) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .rev = 1,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            attrs[i] = *LFSR_ATTR(
                    MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, cfg->block_size, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_rbyd_commit(&lfs, &rbyd,
            LFSR_ATTR(RM, i_, NULL, 0,
            NULL)) => 0;
    BENCH_STOP();
'''
