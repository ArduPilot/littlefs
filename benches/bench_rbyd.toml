# Bench our low-level rbyd data-structure

# set block_size to the full size of disk so we can test arbitrarily
# large rbyd trees, we don't really care about block sizes at this
# abstraction level
defines.BLOCK_SIZE = 'DISK_SIZE'

[cases.bench_rbyd_attr_commit]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, CFG) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    BENCH_START();
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                    "\xaa\xaa\xaa\xaa", 4);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs, N) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
                    LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                        "\xaa\xaa\xaa\xaa", 4))) => 0;
        }
    }
    BENCH_STOP();

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, CFG->block_size) => 0;
'''

[cases.bench_rbyd_attr_fetch]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, CFG) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                    "\xaa\xaa\xaa\xaa", 4);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs, N) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
                    LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                        "\xaa\xaa\xaa\xaa", 4))) => 0;
        }
    }

    BENCH_START();
    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, CFG->block_size) => 0;
    BENCH_STOP();
'''

[cases.bench_rbyd_attr_lookup]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, CFG) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                    "\xaa\xaa\xaa\xaa", 4);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs, N) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
                    LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                        "\xaa\xaa\xaa\xaa", 4))) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, CFG->block_size) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_data_t data_;
    int err = lfsr_rbyd_lookup(&lfs, &rbyd, -1, LFSR_TAG_UATTR(i_ & 0xff),
            NULL, &data_);
    // note that random order may have some collisions
    assert(!err || err == LFS_ERR_NOENT);
    BENCH_STOP();
'''

[cases.bench_rbyd_attr_append]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, CFG) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                    "\xaa\xaa\xaa\xaa", 4);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs, N) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
                    LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                        "\xaa\xaa\xaa\xaa", 4))) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, CFG->block_size) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
            LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                "\xbb\xbb\xbb\xbb", 4))) => 0;
    BENCH_STOP();

    uint8_t buffer[4];
    lfsr_rbyd_get(&lfs, &rbyd, -1, LFSR_TAG_UATTR(i_ & 0xff), buffer, 4) => 4;
    assert(memcmp(buffer, "\xbb\xbb\xbb\xbb", 4) == 0);
'''

[cases.bench_rbyd_attr_remove]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, CFG) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                    "\xaa\xaa\xaa\xaa", 4);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs, N) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
                    LFSR_ATTR(-1, UATTR(i_ & 0xff), 0,
                        "\xaa\xaa\xaa\xaa", 4))) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, CFG->block_size) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
            LFSR_ATTR(-1, RMUATTR(i_ & 0xff), 0, NULL, 0))) => 0;
    BENCH_STOP();

    uint8_t buffer[4];
    lfsr_rbyd_get(&lfs, &rbyd, -1, LFSR_TAG_UATTR(i_ & 0xff), buffer, 4)
            => LFS_ERR_NOENT;
'''

[cases.bench_rbyd_id_commit]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, CFG) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    BENCH_START();
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            attrs[i] = LFSR_ATTR(i_, REG, +1, "\xaa\xaa\xaa\xaa", 4);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs, N) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
                    LFSR_ATTR(i_, REG, +1, "\xaa\xaa\xaa\xaa", 4))) => 0;
        }
    }
    BENCH_STOP();

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, CFG->block_size) => 0;
'''

[cases.bench_rbyd_id_fetch]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, CFG) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            attrs[i] = LFSR_ATTR(i_, REG, +1, "\xaa\xaa\xaa\xaa", 4);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs, N) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
                    LFSR_ATTR(i_, REG, +1, "\xaa\xaa\xaa\xaa", 4))) => 0;
        }
    }

    BENCH_START();
    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, CFG->block_size) => 0;
    BENCH_STOP();
'''

[cases.bench_rbyd_id_lookup]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, CFG) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            attrs[i] = LFSR_ATTR(i_, REG, +1, "\xaa\xaa\xaa\xaa", 4);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs, N) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
                    LFSR_ATTR(i_, REG, +1, "\xaa\xaa\xaa\xaa", 4))) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, CFG->block_size) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_data_t data_;
    lfsr_rbyd_lookup(&lfs, &rbyd, i_, LFSR_TAG_REG,
            NULL, &data_) => 0;
    BENCH_STOP();
'''

[cases.bench_rbyd_id_create]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, CFG) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            attrs[i] = LFSR_ATTR(i_, REG, +1, "\xaa\xaa\xaa\xaa", 4);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs, N) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
                    LFSR_ATTR(i_, REG, +1, "\xaa\xaa\xaa\xaa", 4))) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, CFG->block_size) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % (N+1);
    lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
            LFSR_ATTR(i_, REG, +1, "\xbb\xbb\xbb\xbb", 4))) => 0;
    BENCH_STOP();

    uint8_t buffer[4];
    lfsr_rbyd_get(&lfs, &rbyd, i_, LFSR_TAG_REG, buffer, 4) => 4;
    assert(memcmp(buffer, "\xbb\xbb\xbb\xbb", 4) == 0);
'''

[cases.bench_rbyd_id_delete]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    lfs_t lfs;
    lfs_init(&lfs, CFG) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .off = 0,
        .crc = 0,
        .trunk = 0,
        .weight = 0,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            attrs[i] = LFSR_ATTR(i_, REG, +1, "\xaa\xaa\xaa\xaa", 4);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs, N) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.weight+1);
            lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
                    LFSR_ATTR(i_, REG, +1, "\xaa\xaa\xaa\xaa", 4))) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, CFG->block_size) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_rbyd_commit(&lfs, &rbyd, LFSR_ATTRS(
            LFSR_ATTR(i_, UNR, -1, NULL, 0))) => 0;
    BENCH_STOP();
'''
