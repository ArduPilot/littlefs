[cases.bench_rbyd_attr_commit]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    // set block_size to the full size of disk so we can test arbitrarily
    // large rbyd trees, we don't really care about block sizes at this
    // abstraction level
    struct lfs_config cfg_ = *cfg;
    cfg_.block_size = cfg->block_size*cfg->block_count;
    cfg_.block_count = 1;

    lfs_t lfs;
    lfs_init(&lfs, &cfg_) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .trunk = 0,
        .off = 0,
        .rev = 1,
        .crc = 0,
        .count = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    BENCH_START();
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = *LFSR_ATTR2(
                    UATTR, i_, -1, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR2(UATTR, i_ & 0xff, -1, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }
    BENCH_STOP();

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, NULL) => 0;
'''

[cases.bench_rbyd_attr_fetch]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    // set block_size to the full size of disk so we can test arbitrarily
    // large rbyd trees, we don't really care about block sizes at this
    // abstraction level
    struct lfs_config cfg_ = *cfg;
    cfg_.block_size = cfg->block_size*cfg->block_count;
    cfg_.block_count = 1;

    lfs_t lfs;
    lfs_init(&lfs, &cfg_) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .trunk = 0,
        .off = 0,
        .rev = 1,
        .crc = 0,
        .count = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = *LFSR_ATTR2(
                    UATTR, i_, -1, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR2(UATTR, i_ & 0xff, -1, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    BENCH_START();
    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, NULL) => 0;
    BENCH_STOP();
'''

[cases.bench_rbyd_attr_lookup]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    // set block_size to the full size of disk so we can test arbitrarily
    // large rbyd trees, we don't really care about block sizes at this
    // abstraction level
    struct lfs_config cfg_ = *cfg;
    cfg_.block_size = cfg->block_size*cfg->block_count;
    cfg_.block_count = 1;

    lfs_t lfs;
    lfs_init(&lfs, &cfg_) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .trunk = 0,
        .off = 0,
        .rev = 1,
        .crc = 0,
        .count = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = *LFSR_ATTR2(
                    UATTR, i_, -1, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR2(UATTR, i_ & 0xff, -1, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfs_off_t off;
    lfs_size_t size;
    lfsr_rbyd_lookup(&lfs, &rbyd, LFSR_TAG2(UATTR, i_ & 0xff, -1), &off, &size);
    BENCH_STOP();
'''

[cases.bench_rbyd_attr_append]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    // set block_size to the full size of disk so we can test arbitrarily
    // large rbyd trees, we don't really care about block sizes at this
    // abstraction level
    struct lfs_config cfg_ = *cfg;
    cfg_.block_size = cfg->block_size*cfg->block_count;
    cfg_.block_count = 1;

    lfs_t lfs;
    lfs_init(&lfs, &cfg_) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .trunk = 0,
        .off = 0,
        .rev = 1,
        .crc = 0,
        .count = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = *LFSR_ATTR2(
                    UATTR, i_, -1, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR2(UATTR, i_ & 0xff, -1, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_rbyd_commit(&lfs, &rbyd,
            LFSR_ATTR2(UATTR, i_, -1, "\xbb\xbb\xbb\xbb", 4, NULL)) => 0;
    BENCH_STOP();

    uint8_t buffer[4];
    lfsr_rbyd_get(&lfs, &rbyd, LFSR_TAG2(UATTR, i_, -1), buffer, 4) => 4;
    assert(memcmp(buffer, "\xbb\xbb\xbb\xbb", 4) == 0);
'''

[cases.bench_rbyd_attr_remove]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    // set block_size to the full size of disk so we can test arbitrarily
    // large rbyd trees, we don't really care about block sizes at this
    // abstraction level
    struct lfs_config cfg_ = *cfg;
    cfg_.block_size = cfg->block_size*cfg->block_count;
    cfg_.block_count = 1;

    lfs_t lfs;
    lfs_init(&lfs, &cfg_) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .trunk = 0,
        .off = 0,
        .rev = 1,
        .crc = 0,
        .count = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // build the attribute list for the current permutations
    //
    // NOTE we only have 256 user attributes, so this benchmark is
    // a bit limited
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            attrs[i] = *LFSR_ATTR2(
                    UATTR, i_, -1, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? (N-1-i)
                    : BENCH_PRNG(&prng) % N;
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR2(UATTR, i_ & 0xff, -1, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_rbyd_commit(&lfs, &rbyd,
            LFSR_ATTR2(RMUATTR, i_, -1, NULL, 0, NULL)) => 0;
    BENCH_STOP();

    uint8_t buffer[4];
    lfsr_rbyd_get(&lfs, &rbyd, LFSR_TAG2(UATTR, i_, -1), buffer, 4)
            => LFS_ERR_NOENT;
'''

[cases.bench_rbyd_id_commit]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    // set block_size to the full size of disk so we can test arbitrarily
    // large rbyd trees, we don't really care about block sizes at this
    // abstraction level
    struct lfs_config cfg_ = *cfg;
    cfg_.block_size = cfg->block_size*cfg->block_count;
    cfg_.block_count = 1;

    lfs_t lfs;
    lfs_init(&lfs, &cfg_) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .trunk = 0,
        .off = 0,
        .rev = 1,
        .crc = 0,
        .count = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    BENCH_START();
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.count+1);
            attrs[i] = *LFSR_ATTR(
                    MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.count+1);
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }
    BENCH_STOP();

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, NULL) => 0;
'''

[cases.bench_rbyd_id_fetch]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    // set block_size to the full size of disk so we can test arbitrarily
    // large rbyd trees, we don't really care about block sizes at this
    // abstraction level
    struct lfs_config cfg_ = *cfg;
    cfg_.block_size = cfg->block_size*cfg->block_count;
    cfg_.block_count = 1;

    lfs_t lfs;
    lfs_init(&lfs, &cfg_) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .trunk = 0,
        .off = 0,
        .rev = 1,
        .crc = 0,
        .count = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.count+1);
            attrs[i] = *LFSR_ATTR(
                    MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.count+1);
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    BENCH_START();
    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, NULL) => 0;
    BENCH_STOP();
'''

[cases.bench_rbyd_id_lookup]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*N <= BLOCK_SIZE'
code = '''
    // set block_size to the full size of disk so we can test arbitrarily
    // large rbyd trees, we don't really care about block sizes at this
    // abstraction level
    struct lfs_config cfg_ = *cfg;
    cfg_.block_size = cfg->block_size*cfg->block_count;
    cfg_.block_count = 1;

    lfs_t lfs;
    lfs_init(&lfs, &cfg_) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .trunk = 0,
        .off = 0,
        .rev = 1,
        .crc = 0,
        .count = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.count+1);
            attrs[i] = *LFSR_ATTR(
                    MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.count+1);
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfs_off_t off;
    lfs_size_t size;
    lfsr_rbyd_lookup(&lfs, &rbyd, LFSR_TAG(MKREG, i_), &off, &size)
            => LFSR_TAG(MKREG, i_);
    BENCH_STOP();
'''

[cases.bench_rbyd_id_create]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    // set block_size to the full size of disk so we can test arbitrarily
    // large rbyd trees, we don't really care about block sizes at this
    // abstraction level
    struct lfs_config cfg_ = *cfg;
    cfg_.block_size = cfg->block_size*cfg->block_count;
    cfg_.block_count = 1;

    lfs_t lfs;
    lfs_init(&lfs, &cfg_) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .trunk = 0,
        .off = 0,
        .rev = 1,
        .crc = 0,
        .count = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.count+1);
            attrs[i] = *LFSR_ATTR(
                    MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.count+1);
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % (N+1);
    lfsr_rbyd_commit(&lfs, &rbyd,
            LFSR_ATTR(MKREG, i_, "\xbb\xbb\xbb\xbb", 4,
            NULL)) => 0;
    BENCH_STOP();

    uint8_t buffer[4];
    lfsr_rbyd_get(&lfs, &rbyd, LFSR_TAG(MKREG, i_), buffer, 4) => 4;
    assert(memcmp(buffer, "\xbb\xbb\xbb\xbb", 4) == 0);
'''

[cases.bench_rbyd_id_delete]
# 0 = in-order
# 1 = reversed-order
# 2 = random-order
defines.ORDER = [0, 1, 2]
# 0 = 1 commit
# 1 = N commits
defines.COMMIT = [0, 1]
defines.N = [8, 16, 32, 64, 128, 256, 1024, 2048, 4096]
in = 'lfs.c'
if = 'COMMIT == 0 || PROG_SIZE*(N+1) <= BLOCK_SIZE'
code = '''
    // set block_size to the full size of disk so we can test arbitrarily
    // large rbyd trees, we don't really care about block sizes at this
    // abstraction level
    struct lfs_config cfg_ = *cfg;
    cfg_.block_size = cfg->block_size*cfg->block_count;
    cfg_.block_count = 1;

    lfs_t lfs;
    lfs_init(&lfs, &cfg_) => 0;

    lfsr_rbyd_t rbyd = {
        .block = 0,
        .trunk = 0,
        .off = 0,
        .rev = 1,
        .crc = 0,
        .count = 0,
        .erased = true,
    };
    lfs_bd_erase(&lfs, rbyd.block) => 0;

    // create commits, note we need to take care to generate
    // indexes within a valid range as the rbyd grows
    uint32_t prng = 42;
    if (COMMIT == 0) {
        struct lfsr_attr attrs[N];
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.count+1);
            attrs[i] = *LFSR_ATTR(
                    MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    (i+1 < N) ? &attrs[i+1] : NULL);
        }
        lfsr_rbyd_commit(&lfs, &rbyd, attrs) => 0;
    } else {
        for (lfs_size_t i = 0; i < N; i++) {
            lfs_off_t i_
                    = (ORDER == 0) ? i
                    : (ORDER == 1) ? 0
                    : BENCH_PRNG(&prng) % (rbyd.count+1);
            lfsr_rbyd_commit(&lfs, &rbyd,
                    LFSR_ATTR(MKREG, i_, "\xaa\xaa\xaa\xaa", 4,
                    NULL)) => 0;
        }
    }

    lfsr_rbyd_fetch(&lfs, &rbyd, rbyd.block, NULL) => 0;

    BENCH_START();
    lfs_off_t i_ = BENCH_PRNG(&prng) % N;
    lfsr_rbyd_commit(&lfs, &rbyd,
            LFSR_ATTR(RM, i_, NULL, 0,
            NULL)) => 0;
    BENCH_STOP();
'''
