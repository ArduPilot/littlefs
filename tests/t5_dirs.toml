# Directory tests

[cases.t5_dirs_mkdir]
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
    lfsr_mount(&lfs, cfg) => 0;

    // make a directory
    lfsr_mkdir(&lfs, "ardvark") => 0;

    // check that our mkdir worked
    lfsr_dir_t dir;
    lfsr_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "ardvark") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

    lfsr_unmount(&lfs) => 0;
'''

# test that creating the same directory twice errors
[cases.t5_dirs_mkdir_exists]
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
    lfsr_mount(&lfs, cfg) => 0;

    // make a directory
    lfsr_mkdir(&lfs, "ardvark") => 0;

    // make the same directory, should error
    lfsr_mkdir(&lfs, "ardvark") => LFS_ERR_EXIST;

    // cand check that this didn't interfere with our original directory
    lfsr_dir_t dir;
    lfsr_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "ardvark") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

    lfsr_unmount(&lfs) => 0;
'''

[cases.t5_dirs_mkdir_siblings]
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
    lfsr_mount(&lfs, cfg) => 0;

    // make some directories
    lfsr_mkdir(&lfs, "ardvark") => 0;
    lfsr_mkdir(&lfs, "batman") => 0;
    lfsr_mkdir(&lfs, "cantaloupe") => 0;

    // check that our mkdir worked
    lfsr_dir_t dir;
    lfsr_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "ardvark") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "batman") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "cantaloupe") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

    lfsr_unmount(&lfs) => 0;
'''

[cases.t5_dirs_mkdir_children]
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
    lfsr_mount(&lfs, cfg) => 0;

    // make some directories
    lfsr_mkdir(&lfs, "ardvark") => 0;
    lfsr_mkdir(&lfs, "ardvark/batman") => 0;
    lfsr_mkdir(&lfs, "ardvark/batman/cantaloupe") => 0;

    // check that our mkdirs worked
    lfsr_dir_t dir;
    lfsr_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "ardvark") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

    lfsr_dir_open(&lfs, &dir, "/ardvark") => 0;
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "batman") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

    lfsr_dir_open(&lfs, &dir, "/ardvark/batman") => 0;
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "cantaloupe") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

    lfsr_unmount(&lfs) => 0;
'''

[cases.t5_dirs_mkdir_many]
defines.N = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
    lfsr_mount(&lfs, cfg) => 0;

    // make this many directories
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%04d", i);
        lfsr_mkdir(&lfs, name) => 0;
    }

    // check that our mkdir worked
    lfsr_dir_t dir;
    lfsr_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == LFS_TYPE_DIR);
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%04d", i);
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, name) == 0);
        assert(info.type == LFS_TYPE_DIR);
    }
    lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

    lfsr_unmount(&lfs) => 0;
'''

[cases.t5_dirs_mkdir_many_2layers]
defines.N = [1, 2, 4, 8, 16, 32]
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
    lfsr_mount(&lfs, cfg) => 0;

    // make this many directories
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%04d", i);
        lfsr_mkdir(&lfs, name) => 0;

        // containing this many directories
        for (lfs_size_t j = 0; j < N; j++) {
            sprintf(name, "dir%04d/child%04d", i, j);
            lfsr_mkdir(&lfs, name) => 0;
        }
    }

    // check that our mkdirs worked
    lfsr_dir_t dir;
    lfsr_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == LFS_TYPE_DIR);
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%04d", i);
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, name) == 0);
        assert(info.type == LFS_TYPE_DIR);
    }
    lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%04d", i);
        lfsr_dir_open(&lfs, &dir, name) => 0;
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, ".") == 0);
        assert(info.type == LFS_TYPE_DIR);
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, "..") == 0);
        assert(info.type == LFS_TYPE_DIR);
        for (lfs_size_t j = 0; j < N; j++) {
            char name[256];
            sprintf(name, "child%04d", j);
            lfsr_dir_read(&lfs, &dir, &info) => 0;
            assert(strcmp(info.name, name) == 0);
            assert(info.type == LFS_TYPE_DIR);
        }
        lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;
    }

    lfsr_unmount(&lfs) => 0;
'''

[cases.t5_dirs_mkdir_many_3layers]
defines.N = [1, 2, 4, 8]
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
    lfsr_mount(&lfs, cfg) => 0;

    // make this many directories
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%04d", i);
        lfsr_mkdir(&lfs, name) => 0;

        // containing this many directories
        for (lfs_size_t j = 0; j < N; j++) {
            sprintf(name, "dir%04d/child%04d", i, j);
            lfsr_mkdir(&lfs, name) => 0;

            // containing this many directories
            for (lfs_size_t k = 0; k < N; k++) {
                sprintf(name, "dir%04d/child%04d/grandchild%04d", i, j, k);
                lfsr_mkdir(&lfs, name) => 0;
            }
        }
    }

    // check that our mkdirs worked
    lfsr_dir_t dir;
    lfsr_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == LFS_TYPE_DIR);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == LFS_TYPE_DIR);
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%04d", i);
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, name) == 0);
        assert(info.type == LFS_TYPE_DIR);
    }
    lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%04d", i);
        lfsr_dir_open(&lfs, &dir, name) => 0;
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, ".") == 0);
        assert(info.type == LFS_TYPE_DIR);
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, "..") == 0);
        assert(info.type == LFS_TYPE_DIR);
        for (lfs_size_t j = 0; j < N; j++) {
            char name[256];
            sprintf(name, "child%04d", j);
            lfsr_dir_read(&lfs, &dir, &info) => 0;
            assert(strcmp(info.name, name) == 0);
            assert(info.type == LFS_TYPE_DIR);
        }
        lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

        for (lfs_size_t j = 0; j < N; j++) {
            char name[256];
            sprintf(name, "dir%04d/child%04d", i, j);
            lfsr_dir_open(&lfs, &dir, name) => 0;
            lfsr_dir_read(&lfs, &dir, &info) => 0;
            assert(strcmp(info.name, ".") == 0);
            assert(info.type == LFS_TYPE_DIR);
            lfsr_dir_read(&lfs, &dir, &info) => 0;
            assert(strcmp(info.name, "..") == 0);
            assert(info.type == LFS_TYPE_DIR);
            for (lfs_size_t k = 0; k < N; k++) {
                char name[256];
                sprintf(name, "grandchild%04d", k);
                lfsr_dir_read(&lfs, &dir, &info) => 0;
                assert(strcmp(info.name, name) == 0);
                assert(info.type == LFS_TYPE_DIR);
            }
            lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;
        }
    }

    lfsr_unmount(&lfs) => 0;
'''

[cases.t5_dirs_mkdir_many_linkedlist]
defines.N = [1, 2, 4, 8, 16, 32, 64]
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
    lfsr_mount(&lfs, cfg) => 0;

    // create this many directory in a sort of linked-list by nesting
    char name[4096];
    memset(name, 0, sizeof(name));
    for (lfs_size_t i = 0; i < N; i++) {
        sprintf(&name[strlen(name)], "/dir%04d", i);
        lfsr_mkdir(&lfs, name) => 0;
    }

    // check that our mkdir worked
    memset(name, 0, sizeof(name));
    for (lfs_size_t i = 0; i < N; i++) {
        sprintf(&name[strlen(name)], "/dir%04d", i);
        lfsr_dir_t dir;
        lfsr_dir_open(&lfs, &dir, name) => 0;
        struct lfs_info info;
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, ".") == 0);
        assert(info.type == LFS_TYPE_DIR);
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, "..") == 0);
        assert(info.type == LFS_TYPE_DIR);
        if (i < N-1) {
            char name2[256];
            sprintf(name2, "dir%04d", i+1);
            lfsr_dir_read(&lfs, &dir, &info) => 0;
            assert(strcmp(info.name, name2) == 0);
            assert(info.type == LFS_TYPE_DIR);
        }
        lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;
    }

    lfsr_unmount(&lfs) => 0;
'''

[cases.t5_dirs_mkdir_fuzz]
defines.N = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
defines.SAMPLES = 10
# -1 => all pseudo-random seeds
#  n => reproduce a specific seed
defines.SEED = -1
code = '''
    // iterate through severals seeds that we can reproduce easily
    for (uint32_t seed = (SEED == -1 ? 1 : SEED);
            (SEED == -1 ? seed < SAMPLES+1 : seed == SEED);
            seed++) {
        printf("--- seed: %d ---\n", seed);
        // reset lfs here each iteration
        lfs_t lfs;
        lfsr_format(&lfs, cfg) => 0;
        lfsr_mount(&lfs, cfg) => 0;

        // set up a simulation to compare against
        lfs_size_t *sim = malloc(N*sizeof(lfs_size_t));
        lfs_size_t sim_size = 0;

        uint32_t prng = seed;
        for (lfs_size_t i = 0; i < N; i++) {
            // choose a pseudo-random number, truncate to 4 decimals
            lfs_size_t x = TEST_PRNG(&prng) % 1000;

            // insert into our sim
            for (lfs_size_t j = 0;; j++) {
                if (j >= sim_size || sim[j] >= x) {
                    // already seen? skip
                    if (sim[j] == x) {
                        goto next;
                    }

                    // insert
                    memmove(&sim[j+1], &sim[j],
                            (sim_size-j)*sizeof(lfs_size_t));
                    sim_size += 1;
                    sim[j] = x;
                    break;
                }
            }

            // create a directory here
            char name[256];
            sprintf(name, "dir%04d", x);
            lfsr_mkdir(&lfs, name) => 0;
        next:;
        }

        // test that our directories match our simulation
        lfsr_dir_t dir;
        lfsr_dir_open(&lfs, &dir, "/") => 0;
        struct lfs_info info;
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, ".") == 0);
        assert(info.type == LFS_TYPE_DIR);
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, "..") == 0);
        assert(info.type == LFS_TYPE_DIR);
        for (lfs_size_t j = 0; j < sim_size; j++) {
            char name[256];
            sprintf(name, "dir%04d", sim[j]);
            lfsr_dir_read(&lfs, &dir, &info) => 0;
            assert(strcmp(info.name, name) == 0);
            assert(info.type == LFS_TYPE_DIR);
        }
        lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;

        // clean up sim/lfs
        free(sim);
        lfsr_unmount(&lfs) => 0;
    }
'''

# TODO
# [cases.t5_dirs_did_collisions]
# [cases.t5_dirs_did_zero]
# [cases.t5_dirs_did_ones]
# [cases.t5_dirs_did_leb128_alignment]




#[cases.test_dirs_root]
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs) => 0;
#'''
#
#[cases.test_dirs_many_creation]
#defines.N = 'range(3, 100, 3)'
#if = 'N < BLOCK_COUNT/2'
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "dir%03d", i);
#        lfs_mkdir(&lfs, path) => 0;
#    }
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "dir%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_DIR);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs) => 0;
#'''
#
#[cases.test_dirs_many_removal]
#defines.N = 'range(3, 100, 11)'
#if = 'N < BLOCK_COUNT/2'
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "removeme%03d", i);
#        lfs_mkdir(&lfs, path) => 0;
#    }
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "removeme%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_DIR);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs);
#
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "removeme%03d", i);
#        lfs_remove(&lfs, path) => 0;
#    }
#    lfs_unmount(&lfs);
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs) => 0;
#'''
#
#[cases.test_dirs_many_rename]
#defines.N = 'range(3, 100, 11)'
#if = 'N < BLOCK_COUNT/2'
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "test%03d", i);
#        lfs_mkdir(&lfs, path) => 0;
#    }
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "test%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_DIR);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs);
#
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        char oldpath[128];
#        char newpath[128];
#        sprintf(oldpath, "test%03d", i);
#        sprintf(newpath, "tedd%03d", i);
#        lfs_rename(&lfs, oldpath, newpath) => 0;
#    }
#    lfs_unmount(&lfs);
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "tedd%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_DIR);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs);
#'''
#
#[cases.test_dirs_many_reentrant]
#defines.N = [5, 11]
#if = 'BLOCK_COUNT >= 4*N'
#reentrant = true
#code = '''
#    lfs_t lfs;
#    int err = lfs_mount(&lfs, cfg);
#    if (err) {
#        lfs_format(&lfs, cfg) => 0;
#        lfs_mount(&lfs, cfg) => 0;
#    }
#
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "hi%03d", i);
#        err = lfs_mkdir(&lfs, path);
#        assert(err == 0 || err == LFS_ERR_EXIST);
#    }
#
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "hello%03d", i);
#        err = lfs_remove(&lfs, path);
#        assert(err == 0 || err == LFS_ERR_NOENT);
#    }
#
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "hi%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_DIR);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#
#    for (int i = 0; i < N; i++) {
#        char oldpath[128];
#        char newpath[128];
#        sprintf(oldpath, "hi%03d", i);
#        sprintf(newpath, "hello%03d", i);
#        // YES this can overwrite an existing newpath
#        lfs_rename(&lfs, oldpath, newpath) => 0;
#    }
#
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "hello%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_DIR);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "hello%03d", i);
#        lfs_remove(&lfs, path) => 0;
#    }
#
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs) => 0;
#'''
#
#[cases.test_dirs_file_creation]
#defines.N = 'range(3, 100, 11)'
#if = 'N < BLOCK_COUNT/2'
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "file%03d", i);
#        lfs_file_t file;
#        lfs_file_open(&lfs, &file, path,
#                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
#        lfs_file_close(&lfs, &file) => 0;
#    }
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "file%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_REG);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs);
#'''
#
#[cases.test_dirs_file_removal]
#defines.N = 'range(3, 100, 11)'
#if = 'N < BLOCK_COUNT/2'
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "removeme%03d", i);
#        lfs_file_t file;
#        lfs_file_open(&lfs, &file, path,
#                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
#        lfs_file_close(&lfs, &file) => 0;
#    }
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "removeme%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_REG);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs);
#
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "removeme%03d", i);
#        lfs_remove(&lfs, path) => 0;
#    }
#    lfs_unmount(&lfs);
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs) => 0;
#'''
#
#[cases.test_dirs_file_rename]
#defines.N = 'range(3, 100, 11)'
#if = 'N < BLOCK_COUNT/2'
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "test%03d", i);
#        lfs_file_t file;
#        lfs_file_open(&lfs, &file, path,
#                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
#        lfs_file_close(&lfs, &file) => 0;
#    }
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "test%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_REG);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs);
#
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        char oldpath[128];
#        char newpath[128];
#        sprintf(oldpath, "test%03d", i);
#        sprintf(newpath, "tedd%03d", i);
#        lfs_rename(&lfs, oldpath, newpath) => 0;
#    }
#    lfs_unmount(&lfs);
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "tedd%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_REG);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs);
#'''
#
#[cases.test_dirs_file_reentrant]
#defines.N = [5, 25]
#if = 'N < BLOCK_COUNT/2'
#reentrant = true
#code = '''
#    lfs_t lfs;
#    int err = lfs_mount(&lfs, cfg);
#    if (err) {
#        lfs_format(&lfs, cfg) => 0;
#        lfs_mount(&lfs, cfg) => 0;
#    }
#
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "hi%03d", i);
#        lfs_file_t file;
#        lfs_file_open(&lfs, &file, path, LFS_O_CREAT | LFS_O_WRONLY) => 0;
#        lfs_file_close(&lfs, &file) => 0;
#    }
#
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "hello%03d", i);
#        err = lfs_remove(&lfs, path);
#        assert(err == 0 || err == LFS_ERR_NOENT);
#    }
#
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "hi%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_REG);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#
#    for (int i = 0; i < N; i++) {
#        char oldpath[128];
#        char newpath[128];
#        sprintf(oldpath, "hi%03d", i);
#        sprintf(newpath, "hello%03d", i);
#        // YES this can overwrite an existing newpath
#        lfs_rename(&lfs, oldpath, newpath) => 0;
#    }
#
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "hello%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_REG);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "hello%03d", i);
#        lfs_remove(&lfs, path) => 0;
#    }
#
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs) => 0;
#'''
#
#[cases.test_dirs_nested]
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_mkdir(&lfs, "potato") => 0;
#    lfs_file_t file;
#    lfs_file_open(&lfs, &file, "burito",
#            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
#    lfs_file_close(&lfs, &file) => 0;
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_mkdir(&lfs, "potato/baked") => 0;
#    lfs_mkdir(&lfs, "potato/sweet") => 0;
#    lfs_mkdir(&lfs, "potato/fried") => 0;
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "potato") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, ".") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, "..") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, "baked") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, "fried") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, "sweet") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs) => 0;
#
#    // try removing?
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_remove(&lfs, "potato") => LFS_ERR_NOTEMPTY;
#    lfs_unmount(&lfs) => 0;
#
#    // try renaming?
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_rename(&lfs, "potato", "coldpotato") => 0;
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_rename(&lfs, "coldpotato", "warmpotato") => 0;
#    lfs_rename(&lfs, "warmpotato", "hotpotato") => 0;
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_remove(&lfs, "potato") => LFS_ERR_NOENT;
#    lfs_remove(&lfs, "coldpotato") => LFS_ERR_NOENT;
#    lfs_remove(&lfs, "warmpotato") => LFS_ERR_NOENT;
#    lfs_remove(&lfs, "hotpotato") => LFS_ERR_NOTEMPTY;
#    lfs_unmount(&lfs) => 0;
#
#    // try cross-directory renaming
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_mkdir(&lfs, "coldpotato") => 0;
#    lfs_rename(&lfs, "hotpotato/baked", "coldpotato/baked") => 0;
#    lfs_rename(&lfs, "coldpotato", "hotpotato") => LFS_ERR_NOTEMPTY;
#    lfs_remove(&lfs, "coldpotato") => LFS_ERR_NOTEMPTY;
#    lfs_remove(&lfs, "hotpotato") => LFS_ERR_NOTEMPTY;
#    lfs_rename(&lfs, "hotpotato/fried", "coldpotato/fried") => 0;
#    lfs_rename(&lfs, "coldpotato", "hotpotato") => LFS_ERR_NOTEMPTY;
#    lfs_remove(&lfs, "coldpotato") => LFS_ERR_NOTEMPTY;
#    lfs_remove(&lfs, "hotpotato") => LFS_ERR_NOTEMPTY;
#    lfs_rename(&lfs, "hotpotato/sweet", "coldpotato/sweet") => 0;
#    lfs_rename(&lfs, "coldpotato", "hotpotato") => 0;
#    lfs_remove(&lfs, "coldpotato") => LFS_ERR_NOENT;
#    lfs_remove(&lfs, "hotpotato") => LFS_ERR_NOTEMPTY;
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_open(&lfs, &dir, "hotpotato") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, ".") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, "..") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, "baked") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, "fried") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, "sweet") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs) => 0;
#    
#    // final remove
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_remove(&lfs, "hotpotato") => LFS_ERR_NOTEMPTY;
#    lfs_remove(&lfs, "hotpotato/baked") => 0;
#    lfs_remove(&lfs, "hotpotato") => LFS_ERR_NOTEMPTY;
#    lfs_remove(&lfs, "hotpotato/fried") => 0;
#    lfs_remove(&lfs, "hotpotato") => LFS_ERR_NOTEMPTY;
#    lfs_remove(&lfs, "hotpotato/sweet") => 0;
#    lfs_remove(&lfs, "hotpotato") => 0;
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, ".") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, "..") == 0);
#    info.type => LFS_TYPE_DIR;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(strcmp(info.name, "burito") == 0);
#    info.type => LFS_TYPE_REG;
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs) => 0;
#'''
#
#[cases.test_dirs_recursive_remove]
#defines.N = [10, 100]
#if = 'N < BLOCK_COUNT/2'
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_mkdir(&lfs, "prickly-pear") => 0;
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "prickly-pear/cactus%03d", i);
#        lfs_mkdir(&lfs, path) => 0;
#    }
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "prickly-pear") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "cactus%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_DIR);
#        assert(strcmp(info.name, path) == 0);
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs);
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_remove(&lfs, "prickly-pear") => LFS_ERR_NOTEMPTY;
#
#    lfs_dir_open(&lfs, &dir, "prickly-pear") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    for (int i = 0; i < N; i++) {
#        char path[1024];
#        sprintf(path, "cactus%03d", i);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(info.type == LFS_TYPE_DIR);
#        assert(strcmp(info.name, path) == 0);
#        sprintf(path, "prickly-pear/%s", info.name);
#        lfs_remove(&lfs, path) => 0;
#    }
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#
#    lfs_remove(&lfs, "prickly-pear") => 0;
#    lfs_remove(&lfs, "prickly-pear") => LFS_ERR_NOENT;
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_remove(&lfs, "prickly-pear") => LFS_ERR_NOENT;
#    lfs_unmount(&lfs) => 0;
#'''
#
#[cases.test_dirs_other_errors]
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_mkdir(&lfs, "potato") => 0;
#    lfs_file_t file;
#    lfs_file_open(&lfs, &file, "burito",
#            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
#    lfs_file_close(&lfs, &file) => 0;
#    lfs_unmount(&lfs) => 0;
#
#    lfs_mount(&lfs, cfg) => 0;
#
#    lfs_mkdir(&lfs, "potato") => LFS_ERR_EXIST;
#    lfs_mkdir(&lfs, "burito") => LFS_ERR_EXIST;
#    lfs_file_open(&lfs, &file, "burito",
#            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => LFS_ERR_EXIST;
#    lfs_file_open(&lfs, &file, "potato",
#            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => LFS_ERR_EXIST;
#    lfs_dir_t dir;
#    lfs_dir_open(&lfs, &dir, "tomato") => LFS_ERR_NOENT;
#    lfs_dir_open(&lfs, &dir, "burito") => LFS_ERR_NOTDIR;
#    lfs_file_open(&lfs, &file, "tomato", LFS_O_RDONLY) => LFS_ERR_NOENT;
#    lfs_file_open(&lfs, &file, "potato", LFS_O_RDONLY) => LFS_ERR_ISDIR;
#    lfs_file_open(&lfs, &file, "tomato", LFS_O_WRONLY) => LFS_ERR_NOENT;
#    lfs_file_open(&lfs, &file, "potato", LFS_O_WRONLY) => LFS_ERR_ISDIR;
#    lfs_file_open(&lfs, &file, "potato",
#            LFS_O_WRONLY | LFS_O_CREAT) => LFS_ERR_ISDIR;
#
#    lfs_mkdir(&lfs, "/") => LFS_ERR_EXIST;
#    lfs_file_open(&lfs, &file, "/",
#            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => LFS_ERR_EXIST;
#    lfs_file_open(&lfs, &file, "/", LFS_O_RDONLY) => LFS_ERR_ISDIR;
#    lfs_file_open(&lfs, &file, "/", LFS_O_WRONLY) => LFS_ERR_ISDIR;
#    lfs_file_open(&lfs, &file, "/",
#            LFS_O_WRONLY | LFS_O_CREAT) => LFS_ERR_ISDIR;
#
#    // check that errors did not corrupt directory
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    struct lfs_info info;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_REG);
#    assert(strcmp(info.name, "burito") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "potato") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#
#    lfs_unmount(&lfs) => 0;
#
#    // or on disk
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_dir_open(&lfs, &dir, "/") => 0;
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, ".") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "..") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_REG);
#    assert(strcmp(info.name, "burito") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 1;
#    assert(info.type == LFS_TYPE_DIR);
#    assert(strcmp(info.name, "potato") == 0);
#    lfs_dir_read(&lfs, &dir, &info) => 0;
#    lfs_dir_close(&lfs, &dir) => 0;
#    lfs_unmount(&lfs) => 0;
#'''
#
#[cases.test_dirs_seek]
#defines.COUNT = [4, 128, 132]
#if = 'COUNT < BLOCK_COUNT/2'
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_mkdir(&lfs, "hello") => 0;
#    for (int i = 0; i < COUNT; i++) {
#        char path[1024];
#        sprintf(path, "hello/kitty%03d", i);
#        lfs_mkdir(&lfs, path) => 0;
#    }
#    lfs_unmount(&lfs) => 0;
#
#    for (int j = 2; j < COUNT; j++) {
#        lfs_mount(&lfs, cfg) => 0;
#        lfs_dir_t dir;
#        lfs_dir_open(&lfs, &dir, "hello") => 0;
#        struct lfs_info info;
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, ".") == 0);
#        assert(info.type == LFS_TYPE_DIR);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, "..") == 0);
#        assert(info.type == LFS_TYPE_DIR);
#
#        lfs_soff_t pos;
#        for (int i = 0; i < j; i++) {
#            char path[1024];
#            sprintf(path, "kitty%03d", i);
#            lfs_dir_read(&lfs, &dir, &info) => 1;
#            assert(strcmp(info.name, path) == 0);
#            assert(info.type == LFS_TYPE_DIR);
#            pos = lfs_dir_tell(&lfs, &dir);
#            assert(pos >= 0);
#        }
#
#        lfs_dir_seek(&lfs, &dir, pos) => 0;
#        char path[1024];
#        sprintf(path, "kitty%03d", j);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, path) == 0);
#        assert(info.type == LFS_TYPE_DIR);
#
#        lfs_dir_rewind(&lfs, &dir) => 0;
#        sprintf(path, "kitty%03u", 0);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, ".") == 0);
#        assert(info.type == LFS_TYPE_DIR);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, "..") == 0);
#        assert(info.type == LFS_TYPE_DIR);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, path) == 0);
#        assert(info.type == LFS_TYPE_DIR);
#
#        lfs_dir_seek(&lfs, &dir, pos) => 0;
#        sprintf(path, "kitty%03d", j);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, path) == 0);
#        assert(info.type == LFS_TYPE_DIR);
#
#        lfs_dir_close(&lfs, &dir) => 0;
#        lfs_unmount(&lfs) => 0;
#    }
#'''
#
#[cases.test_dirs_toot_seek]
#defines.COUNT = [4, 128, 132]
#if = 'COUNT < BLOCK_COUNT/2'
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < COUNT; i++) {
#        char path[1024];
#        sprintf(path, "hi%03d", i);
#        lfs_mkdir(&lfs, path) => 0;
#    }
#    lfs_unmount(&lfs) => 0;
#
#    for (int j = 2; j < COUNT; j++) {
#        lfs_mount(&lfs, cfg) => 0;
#        lfs_dir_t dir;
#        lfs_dir_open(&lfs, &dir, "/") => 0;
#        struct lfs_info info;
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, ".") == 0);
#        assert(info.type == LFS_TYPE_DIR);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, "..") == 0);
#        assert(info.type == LFS_TYPE_DIR);
#
#        lfs_soff_t pos;
#        for (int i = 0; i < j; i++) {
#            char path[1024];
#            sprintf(path, "hi%03d", i);
#            lfs_dir_read(&lfs, &dir, &info) => 1;
#            assert(strcmp(info.name, path) == 0);
#            assert(info.type == LFS_TYPE_DIR);
#            pos = lfs_dir_tell(&lfs, &dir);
#            assert(pos >= 0);
#        }
#
#        lfs_dir_seek(&lfs, &dir, pos) => 0;
#        char path[1024];
#        sprintf(path, "hi%03d", j);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, path) == 0);
#        assert(info.type == LFS_TYPE_DIR);
#
#        lfs_dir_rewind(&lfs, &dir) => 0;
#        sprintf(path, "hi%03u", 0);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, ".") == 0);
#        assert(info.type == LFS_TYPE_DIR);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, "..") == 0);
#        assert(info.type == LFS_TYPE_DIR);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, path) == 0);
#        assert(info.type == LFS_TYPE_DIR);
#
#        lfs_dir_seek(&lfs, &dir, pos) => 0;
#        sprintf(path, "hi%03d", j);
#        lfs_dir_read(&lfs, &dir, &info) => 1;
#        assert(strcmp(info.name, path) == 0);
#        assert(info.type == LFS_TYPE_DIR);
#
#        lfs_dir_close(&lfs, &dir) => 0;
#        lfs_unmount(&lfs) => 0;
#    }
#'''
#
