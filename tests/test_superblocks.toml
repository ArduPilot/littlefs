# simple format test
[cases.test_superblocks_format]
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
'''

# simple mount/unmount test
[cases.test_superblocks_mount]
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
    lfsr_mount(&lfs, cfg) => 0;
    lfsr_unmount(&lfs) => 0;
'''

# reentrant format
[cases.test_superblocks_reentrant_format]
reentrant = true
code = '''
    lfs_t lfs;
    int err = lfsr_mount(&lfs, cfg);
    if (err) {
        lfsr_format(&lfs, cfg) => 0;
        lfsr_mount(&lfs, cfg) => 0;
    }
    lfsr_unmount(&lfs) => 0;
'''

# invalid mount
[cases.test_superblocks_invalid]
code = '''
    lfs_t lfs;
    lfsr_mount(&lfs, cfg) => LFS_ERR_INVAL;
'''

# superblock cycle detection
[cases.test_superblocks_cycle]
in = 'lfs.c'
code = '''
    // create a cycle
    lfs_t lfs;
    lfsr_format(&lfs, cfg) => 0;
    lfsr_mount(&lfs, cfg) => 0;
    lfsr_mdir_t mdir;
    lfsr_mdir_fetch(&lfs, &mdir, LFSR_MPAIR(0, 1), NULL) => 0;
    uint8_t buf[LFSR_MPAIR_DSIZE];
    lfs_ssize_t d = lfsr_mpair_todisk(&lfs, LFSR_MPAIR(0, 1), buf);
    assert(d >= 0);
    lfsr_mdir_commit(&lfs, &mdir, LFSR_ATTRS(
            LFSR_ATTR(-1, SUPERMDIR, 0, buf, d))) => 0;
    lfsr_unmount(&lfs) => 0;

    // now detect the cycle
    lfsr_mount(&lfs, cfg) => LFS_ERR_CORRUPT;
'''





## simple formatting test
#[cases.test_superblocks_format]
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#'''
#
## mount/unmount
#[cases.test_superblocks_mount]
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_unmount(&lfs) => 0;
#'''
#
## reentrant format
#[cases.test_superblocks_reentrant_format]
#reentrant = true
#code = '''
#    lfs_t lfs;
#    int err = lfs_mount(&lfs, cfg);
#    if (err) {
#        lfs_format(&lfs, cfg) => 0;
#        lfs_mount(&lfs, cfg) => 0;
#    }
#    lfs_unmount(&lfs) => 0;
#'''
#
## invalid mount
#[cases.test_superblocks_invalid_mount]
#code = '''
#    lfs_t lfs;
#    lfs_mount(&lfs, cfg) => LFS_ERR_CORRUPT;
#'''
#
## expanding superblock
#[cases.test_superblocks_expand]
#defines.BLOCK_CYCLES = [32, 33, 1]
#defines.N = [10, 100, 1000]
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#    lfs_mount(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        lfs_file_t file;
#        lfs_file_open(&lfs, &file, "dummy",
#                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
#        lfs_file_close(&lfs, &file) => 0;
#        struct lfs_info info;
#        lfs_stat(&lfs, "dummy", &info) => 0;
#        assert(strcmp(info.name, "dummy") == 0);
#        assert(info.type == LFS_TYPE_REG);
#        lfs_remove(&lfs, "dummy") => 0;
#    }
#    lfs_unmount(&lfs) => 0;
#
#    // one last check after power-cycle
#    lfs_mount(&lfs, cfg) => 0;
#    lfs_file_t file;
#    lfs_file_open(&lfs, &file, "dummy",
#            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
#    lfs_file_close(&lfs, &file) => 0;
#    struct lfs_info info;
#    lfs_stat(&lfs, "dummy", &info) => 0;
#    assert(strcmp(info.name, "dummy") == 0);
#    assert(info.type == LFS_TYPE_REG);
#    lfs_unmount(&lfs) => 0;
#'''
#
## expanding superblock with power cycle
#[cases.test_superblocks_expand_power_cycle]
#defines.BLOCK_CYCLES = [32, 33, 1]
#defines.N = [10, 100, 1000]
#code = '''
#    lfs_t lfs;
#    lfs_format(&lfs, cfg) => 0;
#    for (int i = 0; i < N; i++) {
#        lfs_mount(&lfs, cfg) => 0;
#        // remove lingering dummy?
#        struct lfs_info info;
#        int err = lfs_stat(&lfs, "dummy", &info);
#        assert(err == 0 || (err == LFS_ERR_NOENT && i == 0));
#        if (!err) {
#            assert(strcmp(info.name, "dummy") == 0);
#            assert(info.type == LFS_TYPE_REG);
#            lfs_remove(&lfs, "dummy") => 0;
#        }
#
#        lfs_file_t file;
#        lfs_file_open(&lfs, &file, "dummy",
#                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
#        lfs_file_close(&lfs, &file) => 0;
#        lfs_stat(&lfs, "dummy", &info) => 0;
#        assert(strcmp(info.name, "dummy") == 0);
#        assert(info.type == LFS_TYPE_REG);
#        lfs_unmount(&lfs) => 0;
#    }
#
#    // one last check after power-cycle
#    lfs_mount(&lfs, cfg) => 0;
#    struct lfs_info info;
#    lfs_stat(&lfs, "dummy", &info) => 0;
#    assert(strcmp(info.name, "dummy") == 0);
#    assert(info.type == LFS_TYPE_REG);
#    lfs_unmount(&lfs) => 0;
#'''
#
## reentrant expanding superblock
#[cases.test_superblocks_reentrant_expand]
#defines.BLOCK_CYCLES = [2, 1]
#defines.N = 24
#reentrant = true
#code = '''
#    lfs_t lfs;
#    int err = lfs_mount(&lfs, cfg);
#    if (err) {
#        lfs_format(&lfs, cfg) => 0;
#        lfs_mount(&lfs, cfg) => 0;
#    }
#
#    for (int i = 0; i < N; i++) {
#        // remove lingering dummy?
#        struct lfs_info info;
#        err = lfs_stat(&lfs, "dummy", &info);
#        assert(err == 0 || (err == LFS_ERR_NOENT && i == 0));
#        if (!err) {
#            assert(strcmp(info.name, "dummy") == 0);
#            assert(info.type == LFS_TYPE_REG);
#            lfs_remove(&lfs, "dummy") => 0;
#        }
#
#        lfs_file_t file;
#        lfs_file_open(&lfs, &file, "dummy",
#                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
#        lfs_file_close(&lfs, &file) => 0;
#        lfs_stat(&lfs, "dummy", &info) => 0;
#        assert(strcmp(info.name, "dummy") == 0);
#        assert(info.type == LFS_TYPE_REG);
#    }
#
#    lfs_unmount(&lfs) => 0;
#
#    // one last check after power-cycle
#    lfs_mount(&lfs, cfg) => 0;
#    struct lfs_info info;
#    lfs_stat(&lfs, "dummy", &info) => 0;
#    assert(strcmp(info.name, "dummy") == 0);
#    assert(info.type == LFS_TYPE_REG);
#    lfs_unmount(&lfs) => 0;
#'''
